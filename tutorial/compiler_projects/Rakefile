# -*-mode: ruby; coding: utf-8;-*-

$KCODE = 'UTF-8'
require 'pp'
require 'pathname'
require 'enumerator'

# This is obsolete for future versions of Ruby because functionality
# will be built in:
def cartesian_product(*args)
  result = [[]]
  while [] != args
    t, result = result, []
    b, *args = args
    t.each do |a|
      b.each do |n|
        result << a + [n]
      end
    end
  end
  result
end

debugdefgroups = \
[ 0,
  1,
  #2
]

applications = \
[ :ecu_display,
  :ecu_data_source,
  :ecu_gps_sensor,
  :ecu_proprietary_can,
  :ecu_tractor_bridge,
]

targets = \
[ :x86linux,
  :esx,
  #:win32,
]

# Define the plan. The tasks will be calculated accordingly.
plan = cartesian_product(debugdefgroups, applications, targets)

# The Rakefile's location shall be the base for relative path
# specifications:
cd(File::dirname(__FILE__))

def let(*args)
  yield(*args)
end

# set SVN_AUTH_OPTIONS. (Don't let it use by buildbot. Otherwise the
# credentials will be visible in the report.)
let{
  svnuser, svnpasswd = ENV.values_at('SVNUSER', 'SVNPASSWD')
  return if defined?(SVN_AUTH_OPTIONS)
  SVN_AUTH_OPTIONS = \
  [ svnuser ? [ '--username', svnuser ] : [], 
    svnpasswd ? [ '--password', svnpasswd ] : [] ].flatten
}

C166BIN = Pathname.new('c:/programme/tasking/c166/bin')

# force path extension:
class Pathname
  def ext(*args)
    Pathname.new(self.to_s.ext(*args))
  end
end

if RUBY_PLATFORM =~ /-mswin32$/
  require 'win32ole' # for conversion DSP -> VCPROJ
end

# Execute a command using the MSYS shell. Added temporarily the
# environment for the command.
def msys_sh_command(command)
  orig_env = ENV['PATH']
  begin
    ENV['PATH'] = "/usr/local/bin:/mingw/bin:c:/bin:#{orig_env}"
    sh('c:/msys/1.0/bin/sh.exe', '-c', command)
  ensure
    ENV['PATH'] = orig_env
  end
end

# Get the application name by combining the application base name, the
# target system name and debug definition group number.
def application_name(appl_base, target_system, debugdefgroup = nil)
  extension = debugdefgroup ? "_d#{debugdefgroup}" : ''
  Pathname.new("#{appl_base}_#{target_system}#{extension}")
end

# Get the configuration file name by the application name.
def conf_name(application)
  Pathname.new("conf_#{application}")
end

SUPPORTED_TARGETS = \
( case RUBY_PLATFORM
  when /-linux$/: [ :x86linux ]
  when /-mswin32$/: [ :win32, :esx ]
  end )

def can_build?(target_system)
 SUPPORTED_TARGETS.include?(target_system)
end

ISOAGLIB_DIR = Pathname.new('../..')

SVN = \
( case RUBY_PLATFORM
  when /-linux$/: 'svn'
  when /-mswin32$/: 'C:/Programme/SlikSvn/bin/svn.exe'
  end )

COMMERCIAL_BIOS_DIR = ISOAGLIB_DIR.join('library/commercial_BIOS')
ANY_BIOS_SUBDIR = COMMERCIAL_BIOS_DIR.join('bios_esx')

def svn(*args)
  sh(*[ SVN, args ].flatten)
end  

def svn_graft(url, destination)
  svn [ 'export',
        '--non-interactive',
        '--ignore-externals',
        '--force',
        SVN_AUTH_OPTIONS,
        url,
        destination ]
end

# graft BIOS from repository if missing:
file(ANY_BIOS_SUBDIR){
  svn_graft('http://projects.osb-ag.de/svn/OSB/CommercialBios',
            COMMERCIAL_BIOS_DIR)
}

ANY_TUTORIALS_SUBDIR = ISOAGLIB_DIR.join('examples')

# graft IsoAgLibTutorial from repository if missing:
file(ANY_TUTORIALS_SUBDIR){
  svn_graft('http://projects.osb-ag.de/svn/OSB/IsoAgLibTutorial/IsoAgLibTutorial',
            ISOAGLIB_DIR)
}

# execute mk166 makefile and output to STDOUT
def make166(mak_path)
  err_path = Pathname.new('error.log')
  sh(C166BIN.join('mk166.exe'), '-f', mak_path, '-err', err_path)
ensure
  begin
    # output error log:
    open(err_path){ |err_file| err_file.each(&method(:puts)) }
  rescue
  end
end

plan.each{ |(debugdefgroup, appl_base, target_system)|

  sample_configuration = conf_name(application_name(appl_base, target_system))

  file(sample_configuration => ANY_TUTORIALS_SUBDIR)

  application = application_name(appl_base, target_system, debugdefgroup)
  configuration = conf_name(application)

  file(configuration => sample_configuration) {
    substitute_project_value = lambda{ |x|
      x.gsub(%r{(\bPROJECT\s*=\s*)\w+}, "\\1#{application}") }
    open(sample_configuration, 'r'){ |input_file|
      open(configuration, 'w'){|output_file|
        input_file.each_line{ |line|
          output_file.write(substitute_project_value[line]) }}}
  }

  update_command_parts = \
  [ './update_makefile.sh',
    configuration,
    "--debugdefgroup=#{debugdefgroup}" ]

  task_body_for_x86linux = lambda{
    sh(*update_command_parts)
    build_dir = Pathname.new('kdevelop_make').join(application)
    cd(build_dir){
      # clean
      Pathname::glob("objects_*/*.[od]").each{ |f| rm(f) }
      sh('make')
    }
  }

  task_body_for_win32 = lambda{
    msys_sh_command(update_command_parts.join(' '))
    build_dir = Pathname.new('VC6').join(application)
    dsp, = Pathname::glob(build_dir.join("#{application}*.dsp"))
    vcproj = build_dir.join("#{application}.vcproj")
    puts "TODO: convert #{dsp} to #{vcproj}"
    puts "Try using win32ole."
  }

  task_body_for_tasking_ede = lambda{
    build_dir = Pathname.new('EDE').join(application)
    # delete old pjt files:
    Pathname::glob(build_dir.join('*.pjt')).each{ |f| rm(f) }
    msys_sh_command(update_command_parts.join(' '))
    cd(build_dir){
      pjt_path, = Pathname::glob("#{application}*.pjt")
      psp_path = pjt_path.ext('psp')

      open(psp_path, 'w'){ |psp_file|
        psp_file.puts <<END_OF_PSP
;Codewright Project Space File (do not remove or modify this line)
[Project.".\\#{pjt_path}"]
END_OF_PSP
      }
      mak_path = psp_path.ext('mak')
      # generate makefile:
      sh(C166BIN.join('ede.exe'), '-X"SysQuit"', psp_path, pjt_path)
      make166(mak_path)
    }
  }

  case target_system
  when :x86linux
    task(application, &task_body_for_x86linux)
  when :win32
    task(application, &task_body_for_win32)
  when :esx
    task(application, &task_body_for_tasking_ede)
    task(application => ANY_BIOS_SUBDIR)
  end

  # application depends from configuration:
  task(application => configuration)

  task(application => ANY_TUTORIALS_SUBDIR)

  if can_build?(target_system)
    task(:autobuild => application)
  end
}

task(:all => :autobuild)
task(:default => :autobuild)
