/*! \page PageDeveloperInfo Developer Information

INCLUDE_doc/txt/mainHeaderWithNavbar.txt_INCLUDE

<table class="infobox" border="0">
<tr><th>Section Overview</th></tr>
<tr><td>The following parts are described on the respective pages:
<ol type="I">
    <li> Developer Information Page
        <ul><li> \ref WhereToStart
	        <ul><li> \ref StartToLearn </li>
	        <li> \ref DocOverview </li>
	        <li> \ref GettingHelp </li>
	    </ul></li>
        <li> \ref InfRequirements </li>
        <li> \ref MemoryUsage </li>
        </ul>
    </li>
    <li> \ref PageChanges "Changelog" </li>
    <li> \ref PageTodo </li>
</ol>
</td></tr>
</table>
<br>
<table class="infobox" border="0">
<tr><th>See also</th></tr>
<tr><td>
    <ul>
    <li> \ref InfGeneralInformation </li>
    <li> \ref Contributing </li>
    <li> \ref ToolsUsed </li>
    </ul>
</td></tr>
</table>

<div style="clear:left"></div>

\section WhereToStart  Getting Started with IsoAgLib

\subsection StartToLearn Hands-On Steps

Please start your learning phase with the tutorial examples
on the <a class="el" href="examples.html">example page</a> to get a guided tour through the
various options and features of the library.
Each example has several links to informative HTML pages from where you can get more and
deeper information on the presented topics.

    - read at least some of the <a class="el" href="examples.html">tutorial examples</a> which are organized in groups (first number) and read some of the referenced further documentation:
        - Nr. 0 for simple applications which demonstrate management of ECU as device node at the network
        - Nr. 1 for simple applications which demonstrate usage of base data like tractor speed and distance
        - Nr. 2 for several levels of applications which demonstrate use of process data value exchange (measurement data for monitoring and setpoint setting for control)
        - Nr. 3 for two examples of terminal handling: <b>ISO 11783 virtual terminal</b>
    - check for modules which you should download to get the features you want at \ref HowtoDownload
    - check for pointers at documentation overview pages of the core features of \isoaglib
    - check for installation instructions of vt2iso , a tool to convert XML mask definition to ROM-eable constant variable definition modules at \ref InstallIsoToolVt2Iso
        (<b>you don't have to compile it at Win32, as an EXE is also part of the archive</b>)
    - check for instructions to create IDE project files for applications at \ref HowtoCreateProjectFiles (the presented shell script does the very important and
        rather complicated job of selecting the needed source files for the wanted features of \isoaglib)

<div class="infobox">
<b>Important:</b><br>
All elements with names without "i" at the beginning and which are grouped to
the namespaces __IsoAgLib and __HAL are only interesting for experts who want
to learn the internals of \isoaglib.
</div>

Please be warned that this stuff seems rather complicated if you
are not familiar with object oriented design.  Certain parts might look strange
at first sight: hopefully they will prove helpful in the end for reduction
of code duplication and ease of code maintenance.

One example is the Singleton Pattern, which is used
globally, but is well defined for core service classes like IsoAgLib::IsoTerminal_c.
The use of this template guarantees that the first access is always
performed by a correctly initialised instance.
<br>The correct order of initialisation is realized even if the initialisation
of a core service class depends of the previous initialisation of one or more
other classes.

Please contact the maintainers
<a href="mailto:Achim.Spangler_at_osb-ag:de">Achim Spangler</a> and
<a href="mailto:Martin.Wodok_at_osb-ag:de">Martin Wodok</a> if you do not
understand some parts after having read the provided documentation.


\subsection DocOverview Documentation Overview Pages
Information on the communication services or the hardware abstraction layer can be found on the specific detail and overview pages below:

- \ref LgplSrcOverview "GPL licensed parts overview"

- Communication Services
    - \ref CommOverPage "Communication Services overview"
    - \ref SchedulerPage "Central Scheduler"
    - \ref NetworkMgmtPage "Network Management (i.e. monitor lists)"
    - \ref AppLayerPage "Base Data handling"
    - \ref ProcDataPage "Process Data handling"
    - \ref DataLinkPage "Data Stream Messages with multi packets"
    - \ref XMLspec "Interaction with ISO 11783 Virtual Terminal"

- Hardware Abstraction Layer
    - \ref MainHalPage "HAL for main parts"
    - \ref SuppHalPage "HAL for supplementary parts"

\subsection GettingHelp Getting Help
Please send any questions that you can not solve yourself (using the
available documentation) to the
<a href="http://linux90.idvnet.de/pipermail/isoaglib/">email list of \isoaglib </a>.
The maintainers of the library who subscribe to the list can try to help you out.
Please <a href="http://linux90.idvnet.de/cgi-bin/mailman/listinfo/isoaglib">subscribe to the email list</a>
before you start to
<a href="mailto:isoaglib@linux90:idvnet:de">send emails</a>.
See also the \ref Mailing-Lists section for further information.

\section InfRequirements Requirements
\subsection InfReqPlatform Platform
The \isoaglib is running on the following systems (state 05 April 2004):
- ESX (based on Infineon C167) of <a href="http://www.sensor-technik.de">STW</a>
- Processor Module PM167 based on Infineon C167) of <a href="http://www.sensor-technik.de">STW</a>
- Implement Indicator (IMI) based on Infineon C167) of <a href="http://www.sensor-technik.de">STW</a>
- PC running with LINUX with real RS232 and CAN IO based on the Realtime Test Environment (RTE)
- PC running with LINUX with pure simulating ECU BIOS (CAN communication provided by file I/O)
- PC running with WINDOWS with pure simulating ECU BIOS (CAN communication provided by file I/O or Vector CANcardX)

\subsection InfReqCompiler Compiler
The object oriented design of the \isoaglib is implemented
with C++ and uses the features <b>namespaces</b> and <b>templates</b>. The "Standard Template
Library" (STL) is used as proven and high quality implementation of lists and corresponding standard
algorithms, to avoid individual implementation of standard tasks which would be error prone and would
cause a long work to find an optimal and efficient solution. Each STL element was chosen after a thorough
analysis on runtime and RAM + ROM size overhead, so that an individual implementation would never be better.

The following parts of the STL are used:
- list ( list of nodes with <b>two</b> pointers overhead per stored data item, no reallocation needed,
  navigation in both direction, direct access to first and last element, needed for FIFO buffer )
- slist ( list of nodes with <b>one</b> pointer overhead per stored data item, no reallocation needed,
  navigation only from first to last element, direct access only to first; used for most cases as typical application is storage of
  objects which are iterated from first to last element )
- vector ( array of items which must be reallocated as soon as the reserved capacity is used,
  thus only used for storage of pointers where reallocation is relative cheap and one or two pointers per item would cause too much overhead )
- queue ( optional FIFO for spooling of items to ISO virtual terminal - could be activated at compile time by config setting )
- find ( standardized and optimized algorithm for search in the containers list, slist, vector )
- distance and advance ( algorithms for efficient placement of iterators during copy actions )

The \isoaglib <b>doesn't use</b>:
- multiple inheritance ( as of 2004-12-09 )
- runtime type identification ( RTTI )
- exception handling

Thus compilers which support the so called <b>Extended EC++</b> specification can be used, as long as they provide an adapted
version of the STL.
List of known <b>Extended EC++</b> aware Compilers ( please inform <a href="mailto:a.spangler_at_osb-ag:de">me</a> if you know other
<b>Extended EC++</b> compilers which match these requirements ):
    - <a href="http://www.iar.com/">IAR</a>
    - ... ?

<b>Important note on some compiler specific language extensions - anachronisms:</b><br>
Compilers like Tasking Version 7.56 instantiate implicitly <b>static const</b> variables, so that
the linker is disturbed by multiple definition of the corresponding symbols. This is not C++ standard conformant,
as <b>static const</b> is the typesafe replacement of C-style \#define constants.<br>
So please make shure that you don't activate options of your compiler that would also instantiate variables/symbols for
<b>static const</b> variables.
<br>

Optimizing technologies of modern compilers allow program size and execution speed which
is equivalent or better than comparable C implementations. This is also true for the the several dynamic lists,
where a constant sized array would not be flexible enough or an individual implementation of a dynamic data structure
wouldn't be smarter than the STL counterpart.
<br>
Suitable compilers exists for processors with at least 16 Bit (e.g. the C16x
series). For quick process data management (which are standardized as 32
Bit values) and more flexible heap memory access, a 32 Bit processor is appropriate.
But as all research work is performed with the ECU <b>ESX</b> of <a href="http://www.sensor-technik.de">STW</a>
 which uses the Infineon 16 Bit processor C167, a 32 Bit processor is not obligatory.<br>
From spring 2002 on all three well known compiler manufacturers (<a href="http://www.tasking.com/products/C166-ST10/home.html">Tasking</a>
, <a href="http://www.hightec-rt.com/">HighTec</a>
 and <a href="http://www.keil.com">KEIL</a>
) provide a suitable C++ compiler for C16x processors. The company <a href="http://www.comeaucomputing.com/">Comeau Computing</a>
 creates a C++ extension for a C compiler on demand. Quick high quality integration
of C++ into C compilers is possible with the help of the state of the art
C++ front-end of <a href="http://www.edg.com">EDG</a>
 which have a customer reference list of some <a href="http://www.edg.com/customers.html">well known brands</a>
.<br>
As soon as a project is compiled by a C++ aware compiler, a project can integrate
parts written in C and C++ without any problems.<br>

\subsection InfReqProgrammingSkills Programming Skills
As long as the \isoaglib should only be used as it is, without
analysing or optimizing it, the needed additional C++ skills (in relation
to C) are small. The <b>28</b> current <a class="el" href="examples.html">tutorial examples</a> and the three real
research world examples provide a sufficient introduction in the usage of
C++ and the \isoaglib.<br>
As soon as the internals of the \isoaglib should be understood, the needed level of C++ skills is increased dependent on the configuration of the \isoaglib. Companies who are interested in a reliable guarantee that needed bugfixes
or extensions are realized by external developers (if local developers
are not familiar with C++ and the \isoaglib) should contact <a href="mailto:Achim.Spangler_at_osb-ag:de">Achim Spangler</a>
 to establish commercial support contracts including training, project attendance and \isoaglib ISO 900x certification.<br>
<br><b>
Everybody who wants to get familiar with the \isoaglib should start with the <a class="el" href="examples.html">tutorial examples</a>.</b><br>

\section MemoryUsage Memory Resource Requirements
The \isoaglib was optimized in relation to the old LBS<i><sub>Lib</sub></i> to use as less HEAP
memory as possible. Thus the current \isoaglib uses HEAP only for the following functions:
  - vector for internal scheduling of core functional components with approximate 10 pointers stored in a compact STL <tt>vector<T></tt> (internal data structure: array)
  - vector with <b>pointers</b> to all locally managed identities which are presented at the BUS as a node
    (<b> \isoaglib enables the presentation of more than one node at the BUS</b>)
  - vector of <b>pointers</b> to forward CAN data processing to process data instances, which are located somewhere in the application scope
    with a STL vector<T> with as much pointers as variables are used (you can reserve enough space at system start,
    to avoid reallocation of the internal array);<br>
    <b>this HEAP usage takes only place, if process data are used</b>
  - lists of measurement programs per local process data (only for  IsoAgLib::ProcDataLocal_c or IsoAgLib::ProcDataLocalSimpleSetpoint_c instances)
  - lists for automatic CAN filter management
  - list of entries in ISO monitor list (IsoAgLib::IsoItem_c)
  - vector for global lookup of sensor or actor I/O instances with one <b>pointer</b> per instance (<b> only present if the corresponding I/O feaure is used </b>)

\subsection HeapDerive Derive Needed HEAPSIZE
The HEAP allocation strategy results in the need of <b>11 KByte</b> <tt>HEAPSIZE</tt> for the complete <b>MiniVeg N</b> system, which provides
57 process data for remote access (e.g. Varioterminal), handles several internal CAN nodes, connects to ISO 11783 BUSes with the corresponding
terminal types and is able to directly control fertilizer spreaders which are accessible by process data.<br>
<b>===>></b> Probability for need of more than 20 - 30 KByte is really low for other production systems<br>

\isoaglib provides some debugging <tt>\#define</tt> settings to collect information on needed <tt>HEAPSIZE</tt> for the monitored runtime conditions:
  - <tt>DEBUG_HEAP_USEAGE</tt> causes output of used HEAP amount for each change of HEAP-placed items (see above for information on items which are placed at HEAP)
    on RS232 (please activate RS232 output in project settings for your project)<br>
    -->> direct derive of needed <tt>HEAPSIZE</tt>, if appropriate worst case load conditions are tested
  - <tt>DEBUG_CAN_BUFFER_FILLING</tt> causes output of MAX filling and MIN free space of circular buffers (output filter of individual MsgObj where new MAX filling or
    MIN free space was detected)<br>
    BIOS like the one of STW use special internal buffer memory to store CAN messages in circular buffers;
    each project must define size of this internal memory as a sum for all internal CAN and RS232 buffers<br>
    -->> direct derive of needed size of internal memory block to avoid CAN or RS232 buffer overflow <br>
    -->> \isoaglib supports allocation of two different CAN buffer sizes, so that CAN filters with especially high load can
      get higher buffer size than other CAN filters with lower load (see <tt>CONFIG_CAN_HIGH_LOAD_IDENT_LIST</tt> which is predefined in <tt>isoaglib_config.h</tt> and can
      be overridden in the project specific config file, that is created and updated by update_makefile.sh)

As some HEAP memory overhead can be caused by reallocation or some other small, not logged items, you should add approximate 1 KByte to the derived size.


\subsection HeapStrategy Selection of HEAP Allocation Method
The <i>Standard Template Library (STL)</i> default allocation strategy, which allocates always large chunks of items (Tasking: 40) has the following effects in relation to the malloc_allocation handler:
  - <b>POSITIVE:</b>
    - malloc, which can affect system runtime, is only called one time for a large block of Malloc-Memory (and not for each single item)
    - cycles of creation-deletion-creation-.. <b>don't</b> cause HEAP fragmentation, as long as amplitude of change doesn't affect amount of needed chunks per datatype,
      because organization of items in one chunk is very efficient
    - low overhead in malloc managed memory block list (typical malloc algorithm creates one block per malloc call, each block has pointers to PREV and NEXT -> 8 Byte for large memory modell)
  - <b>NEGATIVE:</b>
    - typical \isoaglib applications will use less than 10 instances of the corresponding data types, so that each chunk will be used just for a low
      percentage (STL uses one chunk per data type like monitor list item; several lists, which hold same data type as node can share space of one chunk)

Thus the \isoaglib prints always the following size information (if <tt>DEBUG_HEAP_USEAGE</tt> is defined):
  - HEAP memory size for malloc_alloc STL allocation handler (set <tt>"OPTIMIZE_HEAPSIZE_IN_FAVOR_OF_SPEED=1"</tt> in project feature setup file)
  - HEAP memory size for default chunk allocation strategy of STL (<b>default</b> value <tt>"OPTIMIZE_HEAPSIZE_IN_FAVOR_OF_SPEED=0"</tt> in project feature setup file)

With this information you can individually decide on the appropriate allocation strategy (<tt>OPTIMIZE_HEAPSIZE_IN_FAVOR_OF_SPEED</tt> in the
project specification file conf_foo).

The following table present some exact numbers for the needed HEAP memory, so that the decision on the HEAP allocation strategy is eased:
( all numbers for 16 Bit CPU with large memory modell; unit Byte)
<table>
<tr><th>Item</th><th>Size without chunks</th><th>Size with chunks</th><th>Typical unused memory per chunk</th><th>Comment</th></tr>

<tr><td>Scheduler Entry</td><td>12 x scheduled items -> 56</td><td>160</td><td>104</td><td>Vector of pointers to 12 scheduled part tasks</td></tr>
<tr><td>Scheduled Times</td><td>12 x scheduled items -> 32</td><td>80</td><td>48</td><td>Vector of uint16_t execution times of scheduled part tasks</td></tr>

<tr><td>ISO 11783 Monitor List Entry (IsoAgLib::IsoItem_c)</td><td>10 x 52 ISO -> 520</td><td>1768</td><td>1248</td><td>Calculated for 10 ECU nodes on monitored BUS</td></tr>

<tr><td>CAN Filter IsoAgLib::MsgObj_c</td><td>10 x 82 -> 820</td><td>2960</td><td>2140</td><td>Depends on used protocol parts -> CAN idents to receive</td></tr>
<tr><td>CAN Filter IsoAgLib::FilterBox_c</td><td>10 x 28 -> 280</td><td>800</td><td>520</td><td>Depends on used protocol parts -> CAN idents to receive</td></tr>

<tr><td>Local Process Data Entry</td><td>10 x pointers to local process data -> 48</td><td>168</td><td>120</td>
  <td>Only if 10 local process data instances are used</td></tr>
<tr><td>Remote Process Data Entry</td><td>10 x pointers to remote process data -> 48</td><td>168</td><td>120</td>
  <td>Only if 10 remote process data instances are used</td></tr>
<tr><td>MeasureProgLocal_c</td><td>10 x 76 -> 760</td><td>2720</td><td>1960</td><td>Only if 10 measure programs are active - one default instance per used IsoAgLib::ProcDataLocal_c or IsoAgLib::ProcDataLocalSimpleSetpoint_c instance</td></tr>

<tr><td>ISO Buffer of IsoAgLib::SendCommand_c</td><td> (only chunk allocation) </td><td>1284 (chunk of 80 commands)</td><td>--</td><td>For buffer of IsoAgLib::SendCommand_c the malloc alloc is for most conditions not more efficient in HEAP use.</td></tr>
<tr><td>ISO Buffer of IsoAgLib::SendUpload_c</td><td>2 x 32 -> 64</td><td>888</td><td>824</td><td>For buffer of IsoAgLib::SendUpload_c the malloc alloc is for most conditions more efficient in HEAP use.</td></tr>

<tr><td><i>SUM ISO 11783</i></td><td><i>3912</i></td><td><i>10996</i></td><td><i>7084</i></td><td>real numbers depend heavily on used features and targeted network configuration</td></tr>
</table>

<b>IMPORTANT:<br>
At least the Tasking compiler uses pages of each 16 KByte in HEAP, where the limits are not defined relative to the beginning of the heap, but are
strictly calculated by multitudes of 0x4000. As one chunk allocation must be fullfilled within one page, the needed <tt>HEAPSIZE</tt> can be approximate
2 KByte larger than needed, if just some few byte of a large chunk doesn't fit into one page. This worst case condition can be avoided for most
applications, if the HEAP is manually located at the beginning of a 0x4000 multitude in the linker/locator setting (at least version 7.56 doesn't place
the HEAP automatically at an optimal address, so that manual control is needed).
</b>


\subsection BiosOsMemory Internal BIOS/OS Memory
ECUs like the several products of <a href="http://www.sensor-technik.de">STW</a> provide a BIOS which implements
core system activities like CAN and RS232 buffer handling, I/O functions like MEAN calculation and peak filtering.
They have an internal memory buffer that holds the CAN and RS232 buffers. Its size can be controled by the setting
<tt>BUFFER_SIZE</tt> in the file <tt>Xos20go.asm</tt>.
The amount of needed internal buffer memory for CAN communication is controlled by the following conditions:
  - amount of CAN channels
  - amount of CAN messages which shall be buffered for <b>sending</b> per CAN controller Message Object<br>
    (this is defined by <tt>CONFIG_CAN_SEND_BUFFER_SIZE</tt> in the file <tt>isoaglib_config.h</tt> and can be overridden
      in the project specific config header which is created and updated by <tt>update_makefile.sh</tt>;
      default setting 20 items for send; therefore 408 Bytes per buffer with 20 items)
The amount of needed internal buffer memory for RS232 handling depends on the used send and receive buffer. The
default size can be controlled by the settings <tt>CONFIG_RS232_DEFAULT_SND_PUF_SIZE</tt> and <tt>CONFIG_RS232_DEFAULT_REC_PUF_SIZE</tt> in <tt>isoaglib_config.h</tt> and can be overridden
in the project specific config header which is created and updated by update_makefile.sh;
These values can be overridden during runtime by interface functions of iRS232IO_c .
Here a 100 char RS232 buffer needs 108 Bytes of the internal STW memory pool.

\subsection LocalizedRAM Normal RAM
The greatest part of the \isoaglib components is created as static variables in RAM,
so that the linker/locator can place everyting at fixed addresses, so that no memory lookup must be performed
during firmware execution.<br>
The following table shows the needed RAM without any HEAP, user or system stack and internal BIOS/OS buffer.
Additionally the approximate 5 KByte which are used by the STW BIOS (tested with the Demo1_20) are subtracted, to show the
real needed RAM amount by an \isoaglib application. Please add the appropriate amount of RAM for the subtracted
memory types for your individual project estimation.<br>
<b>Important:</b><br>
All values are are retrieved from LARGE memory modell project, which is compiled with Tasking EDE 7.56.<br>
The real values might differ to some degree, as only the MAP file of the complete project was analysed. So if anybody has more exact measures, then please send them
for integration.

<table>
<tr><th>Tutorial Example</th><th>RAM usage \isoaglib and application (KByte)</th> </tr>
<tr><td>0_0_AddressClaimIso</td> <td>6</td> </tr>
<tr><td>3_0_VirtualTerminalIso</td> <td>12</td> </tr>
</table>


\subsection Rom Flash ROM
The following table shows the needed ROM without the program ROM amount, which is used by the STW BIOS (tested with the Demo1_20 -> 50 KByte).
As the virtual terminal example 3_0_VirtualTerminalIso contains two bitmaps, its memory size is presented in additional column.<br>
The 3_0_VirtualTerminalIso contains several mask objects, defines some handlers and imeplements one main mask and one alarm mask. Thus the size of the
total project is caused by the mask elements to some degree.<br>
Additionally the project contained the source files for all Virtual Terminal objects,
even if only a few types are used and demonstrated. Thus you can reduce the ROM requirements by removing all unneeded graphic objects from your source file
list (all source files in <tt>xgpl_src/IsoAgLib/comm/ISO_Terminal</tt> are named corresponding to their name in the ISO 11783 standard).<br>
But please make shure, that you remove only files with the pattern (i)vtobject\<VtObject-Name\>_c.[cpp|h] where VtObject-Name is a VtObject that you don't need.
Please also have a look at the <a class="el" href="inherits.html">graphic inheritance diagram</a> to avoid removal of classes, which are needed by classes which you
use in your project (e.g. don't remove vtobjectstring_c if you use vtobjectinputstring_c as the former is it's base class).
<br>
<b>Important:</b><br>
All values are are retrieved from LARGE memory modell project, which is compiled with Tasking EDE 7.56.<br>
The real values might differ to some degree, as only the MAP file of the complete project was analysed. So if anybody has more exact measures, then please send them
for integration.

<table>
<tr><th>Tutorial Example</th><th>ROM usage \isoaglib and application (KByte)</th><th>ROM usage Bitmaps (KByte)</th></tr>
<tr><td>0_0_AddressClaimIso</td>     <td>89</td>                                                             <td>--</td></tr>
<tr><td>3_0_VirtualTerminalIso</td>  <td>180</td>                                                            <td> 3</td></tr>
</table>

\subsection VtClientRomReduction Reduction of VT-Client code dependent on mask contents
An XML-pool usually does not use every existing vt-object.
Since each vtObject, that is compiled and linked unnecessarily, increases the
size of the resulting object code and thus lowers the perfomance, vt2iso is
now able to parse the XML files and look which XML-tags are used, and creates
a new file "IsoTerminalObjectSelection.inc" that contains all necessary
defines for the project. Since this is done automatically, the user normally
does not have to bother about it.

In some rare cases, additional defines are needed even if they are not
existing in any XML file. For that case, a new optional attribute in the
<objectpool> tag has to be used:

<objectpool ... additionally_required_objects="outputlist+outputstring" />

This way, vt2iso puts additional #defines for outputlist and outputstring in
the IsoTerminalObjectSelection.inc independent of the XML file itself.

To use this inc-file, its location has to be put in the conf-file. The section
can look like this:

PRJ_ISO_TERMINAL_OBJECT_SELECTION1="MaskDefinition"

or

PRJ_ISO_TERMINAL_OBJECT_SELECTION1="MaskDefinition/FirstPool"
PRJ_ISO_TERMINAL_OBJECT_SELECTION2="MaskDefinition/SecondPool"

Up to four pools are supported for one client. If no update_makefile is used,
the following line should be added to the config_MyProject - file:

#ifndef PRJ_ISO_TERMINAL_OBJECT_SELECTION1
        #define PRJ_ISO_TERMINAL_OBJECT_SELECTION1 MaskDefinition
#endif

In both cases, the folder is a relative destination from the source directory.
IMPORTANT: If this information is missing in the config file, the object code
will keep all moduls included, like in IsoAgLib revisions before 2.1.0.


*/
