/*! \page PageDeveloperInfo Developer Information

INCLUDE_doc/txt/mainHeaderWithNavbar.txt_INCLUDE

<table class="infobox" border="0">
<tr><th>Section Overview</th></tr>
<tr><td>The following parts are described on the respective pages:
<ol type="I">
    <li> Developer Information Page
        <ul><li> \ref WhereToStart 
	<ul><li> \ref StartToLearn
	    <li> \ref Documentation </li>
	    <li> \ref GettingHelp </li>
	</ul>
	</li>
        <li> \ref MemoryUsage </li>
        </ul>
    </li>
    <li> \ref PageChanges "Changelog" </li>
    <li> \ref PageTodo </li>
</ol>
</td></tr>
</table>
<br>
<table class="infobox" border="0">
<tr><th>See also</th></tr>
<tr><td>
    <ul>
    <li> \ref Contributing </li>
    <li> \ref ToolsUsed </li>
    </ul>
</td></tr>
</table>

<div style="clear:left"></div>

\section WhereToStart  Getting Started with IsoAgLib

\subsection StartToLearn Hands-On Steps

Please start your learning phase with the tutorial examples
on the <a href="examples.html">Example Page</a> to get a guided tour through the
various options and features of the library.
Each example has several links to informative HTML pages from where you can get more and
deeper information on the presented topics.

    - read at least some of the <a href="examples.html">tutorial examples</a> which are organized in groups (first number) and read some of the referenced further documentation:
        - Nr. 0 for simple applications which demonstrate management of ECU as device node at the network
        - Nr. 1 for simple applications which demonstrate usage of base data like tractor speed and distance
        - Nr. 2 for several levels of applications which demonstrate use of process data value exchange (measurement data for monitoring and setpoint setting for control)
        - Nr. 3 for two examples of terminal handling: <b>ISO 11783 virtual terminal</b>
    - check for modules which you should download to get the features you want at \ref HowtoDownload
    - check for pointers at documentation overview pages of the core features of \isoaglib at \ref HowtoLearnIsoAgLib
    - check for installation instructions of vt2iso , a tool to convert XML mask definition to ROM-eable constant variable definition modules at \ref InstallIsoToolVt2Iso
        (<b>you don't have to compile it at Win32, as an EXE is also part of the archive</b>)
    - check for instructions to create IDE project files for applications at \ref HowtoCreateProjectFiles (the presented shell script does the very important and
        rather complicated job of selecting the needed source files for the wanted features of \isoaglib)

<div class="infobox">
<b>Important:</b><br>
All elements with names without "i" at the beginning and which are grouped to
the namespaces __IsoAgLib and __HAL are only interesting for experts who want
to learn the internals of \isoaglib.
</div>

Please be warned that this stuff seems rather complicated if you
are not familiar with object oriented design.  Certain parts might look strange
at first sight: hopefully they will prove helpful in the end for reduction
of code duplication and ease of code maintenance.

One example is the Singleton Pattern, which is used
globally, but is well defined for core service classes like IsoAgLib::IsoTerminal_c.
The use of this template guarantees that the first access is always
performed by a correctly initialised instance.
<br>The correct order of initialisation is realized even if the initialisation
of a core service class depends of the previous initialisation of one or more
other classes.

Please contact the maintainers
<a href="mailto:Achim.Spangler@osb-ag:de">Achim Spangler</a> and
<a href="mailto:Martin.Wodok@osb-ag:de">Martin Wodok</a> if you do not
understand some parts after having read the provided documentation.


\subsection Documentation Documentation Overview Pages

- \link LgplSrcOverview Overview on GPL Licensed Parts of IsoAgLib \endlink
    - \link CommOverPage Documentation on Communication Services of IsoAgLib \endlink
        - \link SchedulerPage Overview on Central Scheduler of IsoAgLib \endlink
        - \link SystemMgmtPage Overview on System Management of IsoAgLib (%i.%e. monitor lists) \endlink
        - \link BaseDataPage Overview on Base Data Handling in IsoAgLib \endlink
        - \link ProcDataPage Overview on Process Data Handling in IsoAgLib \endlink
        - \link XMLspec Overveiw on Interaction with ISO 11783 Virtual Terminal \endlink
    - \link MainHalPage Hardware Abstraction Layer (HAL) for main parts of IsoAgLib \endlink
    - \link SuppHalPage Hardware Abstraction Layer (HAL) for supplementary parts of IsoAgLib \endlink

\subsection GettingHelp Getting Help
Please send any questions that you can not solve yourself (using the
available documentation) to the
<a href="http://linux90.idvnet.de/pipermail/isoaglib/">email list of \isoaglib </a>.
The maintainers of the library who subscribe to the list can try to help you out.
Please <a href="http://linux90.idvnet.de/cgi-bin/mailman/listinfo/isoaglib">subscribe to the email list</a>
before you start to
<a href="mailto:isoaglib@linux90:idvnet:de">send emails</a>.
See also the \ref Mailing-Lists section for further information.

\section MemoryUsage Information on Memory Resource Requirements
The \isoaglib was optimized in relation to the old LBS<i><sub>Lib</sub></i> to use as less HEAP
memory as possible. Thus the current \isoaglib uses HEAP only for the following functions:
  - vector for internal scheduling of core functional components with approximate 10 pointers stored in a compact STL <tt>vector<T></tt> (internal data structure: array)
  - vector with <b>pointers</b> to all locally managed identities which are presented at the BUS as a node
    (<b> \isoaglib enables the presentation of more than one node at the BUS</b>)
  - vector of <b>pointers</b> to forward CAN data processing to process data instances, which are located somewhere in the application scope
    with a STL vector<T> with as much pointers as variables are used (you can reserve enough space at system start,
    to avoid reallocation of the internal array);<br>
    <b>this HEAP usage takes only place, if process data are used</b>
  - lists of measurement programs per local process data (only for  IsoAgLib::ProcDataLocal_c or IsoAgLib::ProcDataLocalSimpleSetpoint_c instances)
  - lists for automatic CAN filter management
  - list of entries in ISO monitor list (IsoAgLib::IsoItem_c)
  - vector for global lookup of sensor or actor I/O instances with one <b>pointer</b> per instance (<b> only present if the corresponding I/O feaure is used </b>)

\subsection HeapDerive Derive Needed HEAPSIZE
The HEAP allocation strategy results in the need of <b>11 KByte</b> <tt>HEAPSIZE</tt> for the complete <b>MiniVeg N</b> system, which provides
57 process data for remote access (e.g. Varioterminal), handles several internal CAN nodes, connects to ISO 11783 BUSes with the corresponding
terminal types and is able to directly control fertilizer spreaders which are accessible by process data.<br>
<b>===>></b> Probability for need of more than 20 - 30 KByte is really low for other production systems<br>

\isoaglib provides some debugging #define settings to collect information on needed <tt>HEAPSIZE</tt> for the monitored runtime conditions:
  - <tt>DEBUG_HEAP_USEAGE</tt> causes output of used HEAP amount for each change of HEAP-placed items (see above for information on items which are placed at HEAP)
    on RS232 (please activate RS232 output in project settings for your project)<br>
    -->> direct derive of needed <tt>HEAPSIZE</tt>, if appropriate worst case load conditions are tested
  - <tt>DEBUG_CAN_BUFFER_FILLING</tt> causes output of MAX filling and MIN free space of circular buffers (output filter of individual MsgObj where new MAX filling or
    MIN free space was detected)<br>
    BIOS like the one of STW use special internal buffer memory to store CAN messages in circular buffers;
    each project must define size of this internal memory as a sum for all internal CAN and RS232 buffers<br>
    -->> direct derive of needed size of internal memory block to avoid CAN or RS232 buffer overflow <br>
    -->> \isoaglib supports allocation of two different CAN buffer sizes, so that CAN filters with especially high load can
      get higher buffer size than other CAN filters with lower load (see <tt>CONFIG_CAN_HIGH_LOAD_IDENT_LIST</tt> which is predefined in <tt>isoaglib_config.h</tt> and can
      be overridden in the project specific config file, that is created and updated by update_makefile.sh)

As some HEAP memory overhead can be caused by reallocation or some other small, not logged items, you should add approximate 1 KByte to the derived size.


\subsection HeapStrategy Selection of HEAP Allocation Method
The <i>Standard Template Library (STL)</i> default allocation strategy, which allocates always large chunks of items (Tasking: 40) has the following effects in relation to the malloc_allocation handler:
  - <b>POSITIVE:</b>
    - malloc, which can affect system runtime, is only called one time for a large block of Malloc-Memory (and not for each single item)
    - cycles of creation-deletion-creation-.. <b>don't</b> cause HEAP fragmentation, as long as amplitude of change doesn't affect amount of needed chunks per datatype,
      because organization of items in one chunk is very efficient
    - low overhead in malloc managed memory block list (typical malloc algorithm creates one block per malloc call, each block has pointers to PREV and NEXT -> 8 Byte for large memory modell)
  - <b>NEGATIVE:</b>
    - typical \isoaglib applications will use less than 10 instances of the corresponding data types, so that each chunk will be used just for a low
      percentage (STL uses one chunk per data type like monitor list item; several lists, which hold same data type as node can share space of one chunk)

Thus the \isoaglib prints always the following size information (if <tt>DEBUG_HEAP_USEAGE</tt> is defined):
  - HEAP memory size for malloc_alloc STL allocation handler (set <tt>"OPTIMIZE_HEAPSIZE_IN_FAVOR_OF_SPEED=1"</tt> in project feature setup file)
  - HEAP memory size for default chunk allocation strategy of STL (<b>default</b> value <tt>"OPTIMIZE_HEAPSIZE_IN_FAVOR_OF_SPEED=0"</tt> in project feature setup file)

With this information you can individually decide on the appropriate allocation strategy (<tt>OPTIMIZE_HEAPSIZE_IN_FAVOR_OF_SPEED</tt> in the
project specification file conf_foo).

The following table present some exact numbers for the needed HEAP memory, so that the decision on the HEAP allocation strategy is eased:
( all numbers for 16 Bit CPU with large memory modell; unit Byte)
<table>
<tr><td>Item</td><td>Size without chunks</td><td>Size with chunks</td><td>Typical unused memory per chunk</td><td>Comment</td></tr>

<tr><td>Scheduler Entry</td><td>12 x scheduled items -> 56</td><td>160</td><td>104</td><td>Vector of pointers to 12 scheduled part tasks</td></tr>
<tr><td>Scheduled Times</td><td>12 x scheduled items -> 32</td><td>80</td><td>48</td><td>Vector of uint16_t execution times of scheduled part tasks</td></tr>

<tr><td>ISO 11783 Monitor List Entry (IsoAgLib::IsoItem_c)</td><td>10 x 52 ISO -> 520</td><td>1768</td><td>1248</td><td>Calculated for 10 ECU nodes on monitored BUS</td></tr>

<tr><td>CAN Filter IsoAgLib::MsgObj_c</td><td>10 x 82 -> 820</td><td>2960</td><td>2140</td><td>Depends on used protocol parts -> CAN idents to receive</td></tr>
<tr><td>CAN Filter IsoAgLib::FilterBox_c</td><td>10 x 28 -> 280</td><td>800</td><td>520</td><td>Depends on used protocol parts -> CAN idents to receive</td></tr>

<tr><td>Local Process Data Entry</td><td>10 x pointers to local process data -> 48</td><td>168</td><td>120</td>
  <td>Only if 10 local process data instances are used</td></tr>
<tr><td>Remote Process Data Entry</td><td>10 x pointers to remote process data -> 48</td><td>168</td><td>120</td>
  <td>Only if 10 remote process data instances are used</td></tr>
<tr><td>MeasureProgLocal_c</td><td>10 x 76 -> 760</td><td>2720</td><td>1960</td><td>Only if 10 measure programs are active - one default instance per used IsoAgLib::ProcDataLocal_c or IsoAgLib::ProcDataLocalSimpleSetpoint_c instance</td></tr>

<tr><td>ISO Buffer of IsoAgLib::SendCommand_c</td><td> (only chunk allocation) </td><td>1284 (chunk of 80 commands)</td><td>--</td><td>For buffer of IsoAgLib::SendCommand_c the malloc alloc is for most conditions not more efficient in HEAP use.</td></tr>
<tr><td>ISO Buffer of IsoAgLib::SendUpload_c</td><td>2 x 32 -> 64</td><td>888</td><td>824</td><td>For buffer of IsoAgLib::SendUpload_c the malloc alloc is for most conditions more efficient in HEAP use.</td></tr>

<tr><td><b>SUM ISO 11783</b></td><td><b>3912</b></td><td><b>10996</b></td><td><b>7084</b></td><td>real numbers depend heavily on used features and targeted network configuration</td></tr>
</table>

<b>IMPORTANT:<br>
At least the Tasking compiler uses pages of each 16 KByte in HEAP, where the limits are not defined relative to the beginning of the heap, but are
strictly calculated by multitudes of 0x4000. As one chunk allocation must be fullfilled within one page, the needed <tt>HEAPSIZE</tt> can be approximate
2 KByte larger than needed, if just some few byte of a large chunk doesn't fit into one page. This worst case condition can be avoided for most
applications, if the HEAP is manually located at the beginning of a 0x4000 multitude in the linker/locator setting (at least version 7.56 doesn't place
the HEAP automatically at an optimal address, so that manual control is needed).
</b>


\subsection BiosOsMemory Internal BIOS/OS Memory
ECUs like the several products of <a href="http://www.sensor-technik.de">STW</a> provide a BIOS which implements
core system activities like CAN and RS232 buffer handling, I/O functions like MEAN calculation and peak filtering.
They have an internal memory buffer that holds the CAN and RS232 buffers. Its size can be controled by the setting
<tt>BUFFER_SIZE</tt> in the file <tt>Xos20go.asm</tt>.
The amount of needed internal buffer memory for CAN communication is controlled by the following conditions:
  - amount of CAN channels
  - amount of CAN messages which shall be buffered per CAN controller Message Object<br>
    (this is defined by <tt>CONFIG_CAN_SEND_BUFFER_SIZE</tt>, <tt>CONFIG_CAN_STD_LOAD_REC_BUF_SIZE_MIN</tt> and <tt>CONFIG_CAN_HIGH_LOAD_REC_BUF_SIZE_MIN</tt> in the file <tt>isoaglib_config.h</tt> and can be overridden
      in the project specific config header which is created and updated by <tt>update_makefile.sh</tt>;
      default setting 20 items for send and 15 and 25 items for normal and high load receive;
      therefore 408 Bytes per buffer with 20 items)
This results in approximate <b>6 KByte</b> per CAN channel with the default values (max 15 MsgObj with each 20 items in buffer).<br>
The amount of needed internal buffer memory for RS232 handling depends on the used send and receive buffer. The
default size can be controlled by the settings <tt>CONFIG_RS232_DEFAULT_SND_PUF_SIZE</tt> and <tt>CONFIG_RS232_DEFAULT_REC_PUF_SIZE</tt> in <tt>isoaglib_config.h</tt> and can be overridden
in the project specific config header which is created and updated by update_makefile.sh;
These values can be overridden during runtime by interface functions of iRS232IO_c .
Here a 100 char RS232 buffer needs 108 Bytes of the internal STW memory pool.
<br>
Thus you should set the BIOS/OS internal buffer to approximate <b>7 KByte</b> for one CAN channel and 100 char RS232 send/receive buffer.

\subsection LocalizedRAM Normal RAM
The greatest part of the \isoaglib components is created as static variables in RAM,
so that the linker/locator can place everyting at fixed addresses, so that no memory lookup must be performed
during firmware execution.<br>
The following table shows the needed RAM without any HEAP, user or system stack and internal BIOS/OS buffer.
Additionally the approximate 5 KByte which are used by the STW BIOS (tested with the Demo1_20) are subtracted, to show the
real needed RAM amount by an \isoaglib application. Please add the appropriate amount of RAM for the subtracted
memory types for your individual project estimation.<br>
<b>Important:</b><br>
All values are are retrieved from LARGE memory modell project, which is compiled with Tasking EDE 7.56.<br>
The real values might differ to some degree, as only the MAP file of the complete project was analysed. So if anybody has more exact measures, then please send them
for integration.

<table>
<tr><td><b>Tutorial Example</b></td> <td><b>RAM usage \isoaglib and application (KByte)</b></td> </tr>
<tr><td>0_0_AddressClaimIso</td> <td>6</td> </tr>
<tr><td>3_0_VirtualTerminalIso</td> <td>12</td> </tr>
</table>


\subsection Rom Flash ROM
The following table shows the needed ROM without the program ROM amount, which is used by the STW BIOS (tested with the Demo1_20 -> 50 KByte).
As the virtual terminal example 3_0_VirtualTerminalIso contains two bitmaps, its memory size is presented in additional column.<br>
The 3_0_VirtualTerminalIso contains several mask objects, defines some handlers and imeplements one main mask and one alarm mask. Thus the size of the
total project is caused by the mask elements to some degree.<br>
Additionally the project contained the source files for all Virtual Terminal objects,
even if only a few types are used and demonstrated. Thus you can reduce the ROM requirements by removing all unneeded graphic objects from your source file
list (all source files in <tt>xgpl_src/IsoAgLib/comm/ISO_Terminal</tt> are named corresponding to their name in the ISO 11783 standard).<br>
But please make shure, that you remove only files with the pattern (i)vtobject\<VtObject-Name\>_c.[cpp|h] where VtObject-Name is a VtObject that you don't need.
Please also have a look at the <a href="inherits.html">graphic inheritance diagram</a> to avoid removal of classes, which are needed by classes which you
use in your project (e.g. don't remove vtobjectstring_c if you use vtobjectinputstring_c as the former is it's base class).
<br>
<b>Important:</b><br>
All values are are retrieved from LARGE memory modell project, which is compiled with Tasking EDE 7.56.<br>
The real values might differ to some degree, as only the MAP file of the complete project was analysed. So if anybody has more exact measures, then please send them
for integration.

<table>
<tr><td><b>Tutorial Example</b></td> <td><b>ROM usage \isoaglib and application (KByte)</b></td> <td><b>ROM usage Bitmaps (KByte)</b></td> </tr>
<tr><td>0_0_AddressClaimIso</td>     <td>89</td>                                                             <td>--</td></tr>
<tr><td>3_0_VirtualTerminalIso</td>  <td>180</td>                                                            <td> 3</td></tr>
</table>

*/
