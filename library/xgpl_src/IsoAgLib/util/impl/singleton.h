/*
  singleton.h

  (C) Copyright 2009 - 2010 by OSB AG and developing partners

  See the repository-log for details on the authors and file-history.
  (Repository information can be found at <http://isoaglib.com/download>)

  Use, modification and distribution are subject to the GNU General
  Public License with exceptions for ISOAgLib. (See accompanying
  file LICENSE.txt or copy at <http://isoaglib.com/download/license>)
*/
#ifndef SINGLETON_H_
#define SINGLETON_H_

#include <IsoAgLib/isoaglib_config.h>

/// Check preconditions (defines generated by update_makefile.sh)
#if defined(CAN_INSTANCE_CNT) && defined(PRT_INSTANCE_CNT)
#  define PROP_INSTANCE_CNT (PRT_INSTANCE_CNT - CAN_INSTANCE_CNT)
#else
#  error "You need to specify CAN_INSTANCE_CNT and PRT_INSTANCE_CNT!"
#endif

/// Set default where applicable
#if !defined(RS232_INSTANCE_CNT)
#  define RS232_INSTANCE_CNT 0
#endif


#if defined(OPTIMIZE_HEAPSIZE_IN_FAVOR_OF_SPEED) && defined( __GNUC__ ) && __GNUC__ >= 4
#  include <ext/malloc_allocator.h>
#endif

#if (PRT_INSTANCE_CNT != 1)
  /** the macro SINGLETON allows to define classes independent from the value
    * of PRT_INSTANCE_CNT, so that the compiler selects the appropriate base class during
    * compile time
    * this variant is used by the compiler, if more than one BUSes have to be managed by
    * the IsoAgLib
    */
#  define SINGLETON( CLASS ) SingletonVec<CLASS,PRT_INSTANCE_CNT>
  /** the macro SINGLETON_DERIVED allows to define classes independent from the value
    * of PRT_INSTANCE_CNT, so that the compiler selects the appropriate base class during
    * compile time
    * this variant is used by the compiler, if more than one BUSes have to be managed by
    * the IsoAgLib
    * Difference to SINGLETON is the fact, that this version allows to derive the singleton pattern using class from
    * another class. This is important to avoid multiple inheritance.
    */
#  define SINGLETON_DERIVED( CLASS, BASE ) SingletonDerivedVec<CLASS,BASE,PRT_INSTANCE_CNT>

  /** the macro autoInstance() uses the class  value singletonVecKey
    * to get a corresponding class instance, which is delegated to the same BUS
    */
#  define autoInstance()                    instance( ClientBase::getSingletonVecKey() )

#  define SINGLETON_VEC_KEY_PARAMETER_DEF               int ai_singletonVecKey
#  define SINGLETON_VEC_KEY_PARAMETER_DEFAULT_NULL_DEF  int ai_singletonVecKey = 0
#  define SINGLETON_VEC_KEY_PARAMETER_DEF_WITH_COMMA  , int ai_singletonVecKey
#  define SINGLETON_VEC_KEY_PARAMETER_DEFAULT_NULL_DEF_WITH_COMMA , int ai_singletonVecKey = 0
#  define SINGLETON_VEC_KEY_PARAMETER_USE               ai_singletonVecKey
#  define SINGLETON_VEC_KEY_PARAMETER_USE_WITH_COMMA  , ai_singletonVecKey

#  define SINGLETON_PAR_DOT_DEF(PAR)                     int getSingletonVecKey() const { return PAR.getSingletonVecKey(); }
#  define SINGLETON_PAR_ARR_DEF(PAR)                     int getSingletonVecKey() const { return PAR->getSingletonVecKey(); }
#  define SINGLETON_PAR_BASE_DEF(PAR)       int getSingletonVecKey() const { return PAR::getSingletonVecKey(); }
#  define SINGLETON_MC_DATA_ASSIGN                   mc_data.setSingletonKey( getSingletonVecKey() );
#  define SINGLETON_MEMBER_DEF               ClientBase c_clientBase; \
                                                    int getSingletonVecKey() const { return c_clientBase.getSingletonVecKey(); }
#  define SINGLETON_MEMBER_ASSIGN(PAR)     c_clientBase.setSingletonKey (PAR.c_clientBase.getSingletonVecKey());
#  define SINGLETON_MEMBER_CONSTRUCTOR    c_clientBase( ai_singletonVecKey ),
#  define SINGLETON_MEMBER_COPY_CONSTRUCTOR(PAR) c_clientBase( PAR.getSingletonVecKey() ),
#  define SINGLETON_PARENT_CONSTRUCTOR      ClientBase( ai_singletonVecKey ),

#  define SINGLETON_VEC_KEY_INIT_CALL                   setSingletonKey( ai_singletonVecKey );
#  define SINGLETON_VEC_KEY                             getSingletonVecKey()
#  define SINGLETON_VEC_KEY_WITH_COMMA                , getSingletonVecKey()


#  define getForeignInstance4Comm(PAR)      PAR.getSingletonVecKey()
#  define getIsoBusInstance4Comm()          getIsoBusInstance( getSingletonVecKey() )
#  define getCanInstance4Comm()             getCanInstance( getSingletonVecKey() )
#  define getTimePosGpsInstance4Comm()      getTimePosGpsInstance( getSingletonVecKey() )
#  define getTracGeneralInstance4Comm()     getTracGeneralInstance( getSingletonVecKey() )
#  define getTracFacilitiesInstance4Comm()  getTracFacilitiesInstance( getSingletonVecKey() )
#  define getTracMoveInstance4Comm()        getTracMoveInstance( getSingletonVecKey() )
#  define getTracLightInstance4Comm()       getTracLightInstance( getSingletonVecKey() )
#  define getTracAuxInstance4Comm()         getTracAuxInstance( getSingletonVecKey() )
#  define getTracPtoInstance4Comm()         getTracPtoInstance( getSingletonVecKey() )
#  define getTracGuidanceInstance4Comm()    getTracGuidanceInstance( getSingletonVecKey() )
#  define getTracGuidanceCommandInstance4Comm()  getTracGuidanceCommandInstance( getSingletonVecKey() )
#  define getIsoMonitorInstance4Comm()      getIsoMonitorInstance( getSingletonVecKey() )
#  define getProcessInstance4Comm()         getProcessInstance( getSingletonVecKey() )
#  define getMultiSendInstance4Comm()       getMultiSendInstance( getSingletonVecKey() )
#  define getMultiReceiveInstance4Comm()    getMultiReceiveInstance( getSingletonVecKey() )
#  define getIsoTerminalInstance4Comm()     getIsoTerminalInstance( getSingletonVecKey() )
#  define getIsoRequestPgnInstance4Comm()   getIsoRequestPgnInstance( getSingletonVecKey() )
#  define getIsoFilterManagerInstance4Comm() getIsoFilterManagerInstance( getSingletonVecKey() )
#  define getProprietaryMessageHandlerInstance4Comm() getProprietaryMessageHandlerInstance( getSingletonVecKey() )
#  define getFsManagerInstance4Comm()       getFsManagerInstance( getSingletonVecKey() )

/** the class ClientBase delivers the base information, to concat client class instances
    * with the corresponding server class instance. This is realized by the single
    * attribute singletonVecKey, which is evaluated by the macro autoInstance()
    */
  class ClientBase {
   public:
    ClientBase( int ai_singletonVecKey = 0 ) : mi_singletonVecKey(ai_singletonVecKey){};
    ClientBase( const ClientBase& acrc_src )
      : mi_singletonVecKey(acrc_src.mi_singletonVecKey) { };
    int getSingletonVecKey() const { return mi_singletonVecKey;};
    void setSingletonKey( int aiKey ) { mi_singletonVecKey = aiKey;};
   protected:
    const ClientBase& operator=( const ClientBase& acrc_src )
    { mi_singletonVecKey = acrc_src.mi_singletonVecKey; return *this;};
   private:
    int mi_singletonVecKey;
  };
#else
  /** the macro SINGLETON allows to define classes independent from the value
    * of PRT_INSTANCE_CNT, so that the compiler selects the appropriate base class during
    * compile time
    * this variant is used by the compiler, if only one BUS (common case) has to be managed by
    * the IsoAgLib, so that the additional overhead of SingletonVec is avoided
    */
#  define SINGLETON( CLASS ) Singleton<CLASS>
  /** the macro SINGLETON_DERIVED allows to define classes independent from the value
    * of PRT_INSTANCE_CNT, so that the compiler selects the appropriate base class during
    * compile time
    * this variant is used by the compiler, if only one BUS (common case) has to be managed by
    * the IsoAgLib, so that the additional overhead of SingletonVec is avoided
    * Difference to SINGLETON is the fact, that this version allows to derive the singleton pattern using class from
    * another class. This is important to avoid multiple inheritance.
    */
#  define SINGLETON_DERIVED( CLASS, BASE ) SingletonDerived<CLASS,BASE>


  /** the macro autoInstance() is simply replaced by instance() in cases where only one BUS is managed
    * as the more usual case is only one BUS, this solution creates no unneeded overhead
    */
#  define autoInstance()                  instance()

#  define SINGLETON_VEC_KEY_PARAMETER_DEF
#  define SINGLETON_VEC_KEY_PARAMETER_DEFAULT_NULL_DEF
#  define SINGLETON_VEC_KEY_PARAMETER_DEF_WITH_COMMA
#  define SINGLETON_VEC_KEY_PARAMETER_DEFAULT_NULL_DEF_WITH_COMMA
#  define SINGLETON_VEC_KEY_PARAMETER_USE
#  define SINGLETON_VEC_KEY_PARAMETER_USE_WITH_COMMA

#  define SINGLETON_PAR_DOT_DEF(PAR)
#  define SINGLETON_PAR_ARR_DEF(PAR)
#  define SINGLETON_PAR_BASE_DEF(PAR)

#  define SINGLETON_MC_DATA_ASSIGN
#  define SINGLETON_MEMBER_DEF
#  define SINGLETON_MEMBER_ASSIGN(PAR)
#  define SINGLETON_MEMBER_COPY_CONSTRUCTOR(PAR)
#  define SINGLETON_MEMBER_CONSTRUCTOR
#  define SINGLETON_PARENT_CONSTRUCTOR

#  define SINGLETON_VEC_KEY_INIT_CALL
#  define SINGLETON_VEC_KEY
#  define SINGLETON_VEC_KEY_WITH_COMMA

#  define getForeignInstance4Comm(PAR)
#  define getIsoBusInstance4Comm()          getIsoBusInstance()
#  define getCanInstance4Comm()             getCanInstance()
#  define getTimePosGpsInstance4Comm()      getTimePosGpsInstance()
#  define getTracGeneralInstance4Comm()     getTracGeneralInstance()
#  define getTracFacilitiesInstance4Comm()  getTracFacilitiesInstance()
#  define getTracMoveInstance4Comm()        getTracMoveInstance()
#  define getTracLightInstance4Comm()       getTracLightInstance()
#  define getTracAuxInstance4Comm()         getTracAuxInstance()
#  define getTracPtoInstance4Comm()         getTracPtoInstance()
#  define getTracGuidanceInstance4Comm()    getTracGuidanceInstance()
#  define getTracGuidanceCommandInstance4Comm()  getTracGuidanceCommandInstance()
#  define getIsoMonitorInstance4Comm()      getIsoMonitorInstance()
#  define getProcessInstance4Comm()         getProcessInstance()
#  define getMultiSendInstance4Comm()       getMultiSendInstance()
#  define getMultiReceiveInstance4Comm()    getMultiReceiveInstance()
#  define getIsoTerminalInstance4Comm()     getIsoTerminalInstance()
#  define getIsoRequestPgnInstance4Comm()   getIsoRequestPgnInstance()
#  define getIsoFilterManagerInstance4Comm() getIsoFilterManagerInstance()
#  define getProprietaryMessageHandlerInstance4Comm() getProprietaryMessageHandlerInstance()
#  define getFsManagerInstance4Comm()       getFsManagerInstance()

  /** the class ClientBase delivers the base information, to concat client class instances
    * with the corresponding server class instance. This is realized by the single
    * attribute singletonVecKey, which is evaluated by the macro autoInstance()
    */
  class ClientBase {
   public:
    /** the constructor accepts an attribute, which is ignored in cases where only one BUS
      * is managed. The variant of ClientBase for more than one BUS uses this parameter
      * to store the dedicated BUS for later accesses by autoInstance()
      */
    ClientBase( int /* ai_singletonVecKey is intentionally unused for one-instance version of Singleton */ = 0 ) {};
    ClientBase( const ClientBase& /* acrc_src is intentionally unused for one-instance version of Singleton */ ) { };

    int getSingletonVecKey() const { return 0;};
    void setSingletonKey( int /* riKey is intentionally unused for one-instance version of Singleton */ ) { };
   protected:
    const ClientBase& operator=( const ClientBase& /* acrc_src is intentionally unused for one-instance version of Singleton */ ) { return *this;};
  };
#endif

/** CAN_SINGLETON defines the number of overall CAN busses used by IsoAgLib.
  */
#if (CAN_INSTANCE_CNT != 1)
#  define CAN_SINGLETON( CLASS ) SingletonVec<CLASS,CAN_INSTANCE_CNT>
#else
#  define CAN_SINGLETON( CLASS ) Singleton<CLASS>
#endif


/** PROP_SINGLETON defines the number of proprietary busses to be supported.
  */
#if (PROP_INSTANCE_CNT == 0)
#  define getCanInstance4Prop()   ERROR_not_configured_for_Proprietary_CAN_usage_ERROR
#elif (PROP_INSTANCE_CNT > 1)
#  define PROP_SINGLETON( CLASS ) SingletonVec<CLASS,PROP_INSTANCE_CNT>
#  define getCanInstance4Prop()   ccc getCanInstance( (PRT_INSTANCE_CNT) + getSingletonVecKey() )
#else
#  define PROP_SINGLETON( CLASS ) Singleton<CLASS>
#  if (PRT_INSTANCE_CNT == 0)
#    define getCanInstance4Prop()   getCanInstance()
#  else
#    define getCanInstance4Prop()   getCanInstance( (PRT_INSTANCE_CNT) )
#  endif
#endif


/** RS232_SINGLETON allows to define RS232 classes independent from the specified
  * amount of managed RS232 BUSes.
  */
#if (RS232_INSTANCE_CNT != 1)
#  define RS232_SINGLETON( CLASS ) SingletonVec<CLASS,RS232_INSTANCE_CNT>
#else
#  define RS232_SINGLETON( CLASS ) Singleton<CLASS>
#endif

/** @todo ON REQUEST TASKING: try to remove these include hacks, as soon as Tasking provides a bugfix
    for their broken version 7.x STL headers.
    Official STL headers like "c166/include.cpp/stl_algobase.h"
    where the C-Header \<string.h\> is imported into the global namespace, prevent
    a later include of \<cstring\> ( the correct C++ standard method ) to get
    functions like memmove into "STL_NAMESPACE::" namespace.
    To avoid comparable problems with other compilers, and to avoid any compatibility
    problems with other correct compilers, but which are not used by the maintainers,
    these includes are used for ALL compiler types ( there is only a small impact on
    compile time - but no impact on resulting program ).
*/
#include <new>
#include <cstring>
#include <cstdio>
#include <cstdlib>  // Include before vector or else CNAMESPACE stuff is screwed up for Tasking
#include <vector>

/** BaseSingleton class for classes which need only ONE instance per project
  */
template<class T> class Singleton
{
 public:
  /** return reference to the singleton instance
    * prevent parallel access to initialisation by several tasks
    * @return reference to singleton instance
    */
  static T& instance( void )
  {
    static T* mspc_instance = (T*)0;
    if ( mspc_instance > (T*)1 )
    { // is already complete initialized -> this is THE MOST OFTEN CASE
      return *mspc_instance;
    }
    else if ( mspc_instance == (T*)0 )
    { // in case of parallel access from two tasks, the first tasks block further
      // inits with setting the poitner to 1 -> later tasks perform busy waiting
      if ( mspc_instance == (T*)1 )
      { // perform busy waiting till first task is ready with init
        while ( mspc_instance == (T*)1 ) {}
        // as soon as the pointer is != 1 the init is ready
        return *mspc_instance;
      }
      // if execution reaches this point, Singleton::instance() is called first time
      mspc_instance = (T*)1; // block further calls till init is ready
#ifdef WIN32
      // Microsoft Visual Studio has problems with init of function scope static instances
      mspc_instance = new T;
#else
      static T sc_instance;
      mspc_instance = &sc_instance;
#endif
    }
    else
    { // is set to 1 -> make busy wait ( in case this position is reached due to circular init call,
      // we'll get a definitive endless loop here - fine to debug ;-)
      while ( mspc_instance == (T*)1 ) {}
    }
    return *mspc_instance;
  };
  /** avoid error messages, if this function is called with int parameter
    * in cases, where only a single singleton instance is defined by PRT_INSTANCE_CNT
    */
  static T& instance( int riIndex ) { return instance();};
 protected:
  int getSingletonVecKey() const { return 0;};
};
/** BaseSingleton class for classes which need only ONE instance per project.
    This version of Singleton can be derived from another class.
    This is important to avoid multiple inheritance in the class that uses the
    singleton pattern.
  */
template<class T, class B> class SingletonDerived : public B
{
 public:
  /** return reference to the singleton instance
    * prevent parallel access to initialisation by several tasks
    * @return reference to singleton instance
    */
  static T& instance( void )
  {
    static T* mspc_instance = (T*)0;
    if ( mspc_instance > (T*)1 )
    { // is already complete initialized -> this is THE MOST OFTEN CASE
      return *mspc_instance;
    }
    else if ( mspc_instance == (T*)0 )
    { // in case of parallel access from two tasks, the first tasks block further
      // inits with setting the poitner to 1 -> later tasks perform busy waiting
      if ( mspc_instance == (T*)1 )
      { // perform busy waiting till first task is ready with init
        while ( mspc_instance == (T*)1 ) {}
        // as soon as the pointer is != 1 the init is ready
        return *mspc_instance;
      }
      // if execution reaches this point, Singleton::instance() is called first time
      mspc_instance = (T*)1; // block further calls till init is ready
#ifdef WIN32
      // Microsoft Visual Studio has problems with init of function scope static instances
      mspc_instance = new T;
#else
      static T sc_instance;
      // set static pointer to instance
      mspc_instance = &sc_instance;
#endif
    }
    else
    { // is set to 1 -> make busy wait ( in case this position is reached due to circular init call,
      // we'll get a definitive endless loop here - fine to debug ;-)
      while ( mspc_instance == (T*)1 ) {}
    }
    return *mspc_instance;
  };
  /** avoid error messages, if this function is called with int parameter
    * in cases, where only a single singleton instance is defined by PRT_INSTANCE_CNT
    */
  static T& instance( int riIndex ) { return instance();};
 protected:
  int getSingletonVecKey() const { return 0;};
};


/** scalable variant of base Singleton, which can manage a predefined amount of instances with global access
  */
template<class T, int SIZE> class SingletonVec
{
 public:
  /** return reference to the singleton instance
    * prevent parallel access to initialisation by several tasks
    * @param riIndex selection of the wanted static instance (default first entry)
    * @return reference to singleton instance
    */
  static T& instance( int riIndex = 0 )
  {
    static T * mspc_instance[SIZE] = {(T*)0};
    if ( mspc_instance[0] > (T*)1 )
    { // is already complete initialized -> this is THE MOST OFTEN CASE
      return *mspc_instance[riIndex];
    }
    else if ( mspc_instance[0] == (T*)0 )
    { // in case of parallel access from two tasks, the first tasks block further
      // inits with setting the poitner to 1 -> later tasks perform busy waiting
      if ( mspc_instance[0] == (T*)1 )
      { // perform busy waiting till first task is ready with init
        while ( mspc_instance[0] == (T*)1 ) {}
        // as soon as the pointer is != 1 the init is ready
        return *mspc_instance[riIndex];
      }
      // if execution reaches this point, Singleton::instance() is called first time
      mspc_instance[0] = (T*)1; // block further calls till init is ready
#ifdef WIN32
      for ( int i = 0; i < SIZE; i++)
      {
        mspc_instance[i] = new T;
        mspc_instance[i]->singletonVecKey = i;
      }
#else
      static T sc_instance[SIZE];
      for ( int i = 0; i < SIZE; i++)
      { // initialise the instance (in embedded systems, the constructor is NOT called for static var)
        sc_instance[i].singletonVecKey = i;
        // set static pointer to instance
        mspc_instance[i] = &sc_instance[i];
      }
#endif
    }
    else
    { // is set to 1 -> make busy wait ( in case this position is reached due to circular init call,
      // we'll get a definitive endless loop here - fine to debug ;-)
      while ( mspc_instance[0] == (T*)1 ) {}
    }
    return *mspc_instance[riIndex];
  };
 protected:
  int getSingletonVecKey() const { return singletonVecKey;};
 private:
  int singletonVecKey;
};

/** scalable variant of base Singleton, which can manage a predefined amount of instances with global access
    This version of Singleton can be derived from another class.
    This is important to avoid multiple inheritance in the class that uses the
    singleton pattern.
  */
template<class T, class B, int SIZE> class SingletonDerivedVec : public B
{
 public:
  /** return reference to the singleton instance
    * prevent parallel access to initialisation by several tasks
    * @param riIndex selection of the wanted static instance (default first entry)
    * @return reference to singleton instance
    */
  static T& instance( int riIndex = 0 )
  {
    static T * mspc_instance[SIZE] = {(T*)0};
    if ( mspc_instance[0] > (T*)1 )
    { // is already complete initialized -> this is THE MOST OFTEN CASE
      return *mspc_instance[riIndex];
    }
    else if ( mspc_instance[0] == (T*)0 )
    { // in case of parallel access from two tasks, the first tasks block further
      // inits with setting the poitner to 1 -> later tasks perform busy waiting
      if ( mspc_instance[0] == (T*)1 )
      { // perform busy waiting till first task is ready with init
        while ( mspc_instance[0] == (T*)1 ) {}
        // as soon as the pointer is != 1 the init is ready
        return *mspc_instance[riIndex];
      }
      // if execution reaches this point, Singleton::instance() is called first time
      mspc_instance[0] = (T*)1; // block further calls till init is ready
#ifdef WIN32
      for ( int i = 0; i < SIZE; i++)
      {
        mspc_instance[i] = new T;
        mspc_instance[i]->singletonVecKey = i;
      }
#else
      static T sc_instance[SIZE];
      for ( int i = 0; i < SIZE; i++)
      { // initialise the instance (in embedded systems, the constructor is NOT called for static var)
        sc_instance[i].singletonVecKey = i;
        // set static pointerto instance
        mspc_instance[i] = &sc_instance[i];
      }
#endif
    }
    else
    { // is set to 1 -> make busy wait ( in case this position is reached due to circular init call,
      // we'll get a definitive endless loop here - fine to debug ;-)
      while ( mspc_instance[0] == (T*)1 ) {}
    }
    return *mspc_instance[riIndex];
  };
 protected:
  int getSingletonVecKey() const { return singletonVecKey;};
 private:
  int singletonVecKey;
};

#endif // SINGLETON_H_
