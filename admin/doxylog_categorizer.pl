#!/usr/bin/perl
#
# Description: categorizes and splits the log generated by doxygen into seperate files
# Created    : 15.01.2008 (changed: -)
# Author     : F. Muecke, OSB AG
#
# Logfile format: 
#   	WARN_FORMAT		= "$file:$line :$text "
#	WARNINGS		= YES
#	WARN_IF_UNDOCUMENTED	= YES
#	WARN_IF_DOC_ERROR	= YES
#                

open(FILE, @ARGV[0]) or die "Can't find file $FILE: $!\nusage: @ARGV[0] doxylog\n\n";
@raw=<FILE>;
close(FILE);

while ( defined( $line = shift(@raw) ) )
{
  if ( $line =~ m/matching class member/ )
  {
    $no_class_member .= $line;

    while( defined( $line = shift( @raw ) ) )
    {
      if ( $line !~ m/^\// )
      {
        $no_class_member .= $line;
      }
      else
      {
        unshift( @raw, $line );
	last;
      }
    }
  }

  elsif ( $line =~ m/belongs to/ && $line =~ m/different groups/ )
  {
    $multiple_groups .= $line;

    while( defined( $line = shift( @raw ) ) )
    {
      if ( $line !~ m/^\// )
      {
        $multiple_groups .= $line;
      }
      else
      {
        unshift( @raw, $line );
	last;
      }
    }
  }
  
  elsif ( $line =~ m/matching file member/ )
  {
    $no_file_member .= $line;

    while( defined( $line = shift( @raw ) ) )
    {
      if ( $line !~ m/^\// )
      {
        $no_file_member .= $line;
      }
      else
      {
        unshift( @raw, $line );
	last;
      }
    }
  }

  elsif ( $line =~ m/resolve reference/ )
  {
    $unresolved_ref .= $line;

    while( defined( $line = shift( @raw ) ) )
    {
      if ( $line !~ m/^\// )
      {
        $unresolved_ref .= $line;
      }
      else
      {
        unshift( @raw, $line );
	last;
      }
    }
  }

  elsif ( $line =~ m/parameter/ && $line =~ m/not documented/ )
  {
    $param_undoc .= $line;

    while( defined( $line = shift( @raw ) ) )
    {
      if ( $line !~ m/^\// )
      {
        $param_undoc .= $line;
      }
      else
      {
        unshift( @raw, $line );
	last;
      }
    }
  }

  elsif ( $line =~ m/documented function/ && $line =~ m/not declared or defined/ )
  {
    $func_nodef .= $line;

    while( defined( $line = shift( @raw ) ) )
    {
      if ( $line !~ m/^\// )
      {
        $func_nodef .= $line;
      }
      else
      {
        unshift( @raw, $line );
	last;
      }
    }
  }

  elsif ( $line =~ m/argument/ && $line =~ m/of command \@param is not found in the argument list/ )
  {
    $param_not_found .= $line;

    while( defined( $line = shift( @raw ) ) )
    {
      if ( $line !~ m/^\// )
      {
        $param_not_found .= $line;
      }
      else
      {
        unshift( @raw, $line );
	last;
      }
    }
  }

  elsif ( $line =~ m/comment block/ )
  {
    $comment_block .= $line;

    while( defined( $line = shift( @raw ) ) )
    {
      if ( $line !~ m/^\// )
      {
        $comment_block .= $line;
      }
      else
      {
        unshift( @raw, $line );
	last;
      }
    }
  }

  else
  {
    $misc .= $line;
  }
}

#
# write output
#
open(FILE, ">@ARGV[0]".".multiple_groups" ) or die "Can't open file $FILE: $!\n";
print(FILE $multiple_groups);
close(FILE);

open(FILE, ">@ARGV[0]".".misc" ) or die "Can't open file $FILE: $!\n";
print(FILE $misc);
close(FILE);

open(FILE, ">@ARGV[0]".".no_class_member" ) or die "Can't open file $FILE: $!\n";
print(FILE $no_class_member);
close(FILE);

open(FILE, ">@ARGV[0]".".no_file_member" ) or die "Can't open file $FILE: $!\n";
print(FILE $no_file_member);
close(FILE);

open(FILE, ">@ARGV[0]".".unresolved_ref" ) or die "Can't open file $FILE: $!\n";
print(FILE $unresolved_ref);
close(FILE);

open(FILE, ">@ARGV[0]".".param_undoc" ) or die "Can't open file $FILE: $!\n";
print(FILE $param_undoc);
close(FILE);

open(FILE, ">@ARGV[0]".".func_nodef" ) or die "Can't open file $FILE: $!\n";
print(FILE $func_nodef);
close(FILE);

open(FILE, ">@ARGV[0]".".param_not_found" ) or die "Can't open file $FILE: $!\n";
print(FILE $param_not_found);
close(FILE);

open(FILE, ">@ARGV[0]".".comment_block" ) or die "Can't open file $FILE: $!\n";
print(FILE $comment_block);
close(FILE);

